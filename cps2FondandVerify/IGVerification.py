import copy,os,codecs,re
from GologProgramTree import Nested_list2FOLExp
def IGVerification(parser, domainname,whole_merged_all_sub_fond_domain_and_or_graph):
    """
    Verification of Initial states and Goals  
    """
    LL_formula_for_initial_states = Nested_list2FOLExp().run(copy.deepcopy(parser.formula_for_initial_states))
    LL_formula_for_goals_str = Nested_list2FOLExp().run(copy.deepcopy(parser.formula_for_goals))
    # refinementMap
    refinementMap_Dict = dict()
    for fond_predicate,FOL_formula_cnf in parser.fond_predicates.items():
        refinementMap_Dict[fond_predicate] = Nested_list2FOLExp().run(copy.deepcopy(FOL_formula_cnf))

    initial_states_set = whole_merged_all_sub_fond_domain_and_or_graph.initial_states_set
    goal_states_set = set()
    HLid2HLstate = {}
    HLid2CNF_formula = {}
    for eachhs in whole_merged_all_sub_fond_domain_and_or_graph.allHighStateCollection:
        HLid2CNF_formula[eachhs.highStateid] = dumplowlevelCNFfromhighstateId_without_vStartVGoal(refinementMap_Dict,eachhs)
        HLid2HLstate[eachhs.highStateid] = eachhs
        if eachhs.isGoalState == True:
            goal_states_set.add(eachhs.highStateid)
    
    conjunction_for_HL_initial_states = 'Or('
    conjunction_for_HL_goals = 'Or('    
    for each_i in initial_states_set:
        conjunction_for_HL_initial_states += HLid2CNF_formula[each_i]
        if len(initial_states_set) > 1:
            conjunction_for_HL_initial_states += ','
    if conjunction_for_HL_initial_states[-1] == ',':
        conjunction_for_HL_initial_states = conjunction_for_HL_initial_states[0:-1]
    for each_g in goal_states_set:
        conjunction_for_HL_goals += HLid2CNF_formula[each_g]
        if len(goal_states_set) > 1:
            conjunction_for_HL_goals += ','
    if conjunction_for_HL_goals[-1] == ',':
        conjunction_for_HL_goals = conjunction_for_HL_goals[0:-1]
    conjunction_for_HL_initial_states += ')'
    conjunction_for_HL_goals += ')'

    initial_config  = {
        "LOW_THEOREM":LL_formula_for_initial_states,
        "HIG_THEOREM":conjunction_for_HL_initial_states
    }
    goal_config = {
        "LOW_THEOREM":LL_formula_for_goals_str,
        "HIG_THEOREM":conjunction_for_HL_goals
    }

    # for 'I'/'G' autogenerator_python_prove_file
    autogenerator_python_prove_file_IG(initial_config,'I',parser)
    autogenerator_python_prove_file_IG(goal_config,'G',parser)


def autogenerator_python_prove_file_IG(config,type_of_verification:str(),parser):
    """
    autogenerator_python_prove_file_IG
    """
    # 1. read config 
    # 2. read template.py file
    s = ""
    if type_of_verification == 'I':
        path_of_template_py = r"{0}/autogenerated/domain_template/{1}_IG_template.py".format(\
                        os.path.dirname(os.path.abspath(__file__)), parser.domain_name)
    elif type_of_verification == 'G':
        path_of_template_py = r"{0}/autogenerated/domain_template/{1}_poss_template.py".format(\
                        os.path.dirname(os.path.abspath(__file__)), parser.domain_name)
    with codecs.open(path_of_template_py, "rb", "UTF-8") as f:
        s = f.read()
    if not s:
        return
    # 3. replace template.py with config 
    # %(LOW_THEOREM) ==> %(HIG_THEOREM)
    s = s % config    # save to file
    py_to_be_writed_G = r"{0}/autogenerated/{1}_{2}.py".format(os.path.dirname(os.path.abspath(__file__)),parser.domain_name,type_of_verification)
    fn = r"{0}/autogenerated/{1}_{2}.py".format(\
            os.path.dirname(os.path.abspath(__file__)), parser.domain_name,type_of_verification)
    with codecs.open(fn, "wb", "UTF-8") as f:
        f.write(s)
        f.flush()

def dumplowlevelCNFfromhighstateId_without_vStartVGoal(refinementMap_Dict,eachhs)->str():
        condition_str = "And("
        for each,boolValue in eachhs.highState.items():
            if each == 'vStart' or each == 'vGoal':
                pass
            else:
                if (boolValue == True):
                    condition_str += '('+refinementMap_Dict[each]+'),' 
                else: # (boolValue == False)
                    condition_str += 'Not' + '('+refinementMap_Dict[each]+')' + ',' 
        if condition_str[-1] == ',':
            condition_str = condition_str[0:-1]
        condition_str += ' )'
        return condition_str

# def write_template_py(parser,template_py_to_be_writed):
#     """ 'poss' writed template py.
#         write_template_py(template_py_to_be_writed,hig_name,each_hig_func_number,hig_num_prove_dict) """
#     template_py_to_be_writed = r"{0}/autogenerated/domain_template/{1}_poss_template.py".format(\
#                         os.path.dirname(os.path.abspath(__file__)), parser.domain_name)
#     with open(template_py_to_be_writed,'w',encoding = 'utf-8') as templatefile:
#         # The fixed head tags
#         templatefile.write('# -*- coding: UTF-8 -*-\n')
#         templatefile.write('#!/usr/bin/env python\n')
#         templatefile.write('#-------------------------------------------------------------------------------\n')
#         templatefile.write('# Name:        Automatic verification of I/G for FOND Abstraction.\n')
#         templatefile.write('# Author:      this file is autogenerated by "IGVerification.py/write_template_py()"\n')
#         templatefile.write('# Created:     ' + time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) +'\n' )
#         templatefile.write('# Copyright:   (c) Tridu33 2022\n')
#         templatefile.write('# Licence:     <MIT licence>\n')
#         templatefile.write('#-------------------------------------------------------------------------------\n')
#         templatefile.write('from z3 import *\n')
#         templatefile.write('from func_timeout import func_set_timeout\n')
#         templatefile.write('import func_timeout,time,os\n')
#         sys.path.append("..")
#         templatefile.write('\n')

#         # ==================================================================================  declare objs 2 types
#         allVarConstants2Types = dict()# Dict(): for preprocess/define/DeclareSort()Cons()EnumSort()  
#         allVarConstants2Types.update(parser.constants)
#         allVarConstants2Types.update(parser.ConsForSorts) # Require global different variables can not be used for a while? x represents type one, which will be used for a while? x represents type two


#         allclassTypes = []
#         templatefile.write('\n')
#         # Dict:[x y ,...]--> theRightType
#         for key,value in allVarConstants2Types.items():
#             if value not in allclassTypes:
#                 allclassTypes.append(value)
#                 templatefile.write('{0} = DeclareSort("{0}")\n'.format(value))
#             if key[0] == '?':
#                 templatefile.write('{0} = Const(\'{0}\', {1})\n'.format(key[1:],value))
#             else:
#                 templatefile.write('{0} = Const(\'{0}\', {1})\n'.format(key,value))
#         templatefile.write('\n')

#         # ================================================================================== Predicates
#         templatefile.write('# declare Predicates \n')
#         for key,value in parser.predicates.items():
#             if not value:
#                 templatefile.write('{0} = Bool(\'{0}\')\n'.format(key)) 
#             else:
#                 parser_predicates_TypeInput = str()
#                 for TypeValues in value.values():
#                     parser_predicates_TypeInput += ',' + TypeValues
#                 templatefile.write('{0} = Function(\'{0}\'{1},BoolSort())\n'.format(key,parser_predicates_TypeInput)) 

#         # =============== load constrain axtioms         
#         templatefile.write('\n')
#         templatefile.write('# load and exec domain constraint file of \"{0}\" given by users(background information).\n'.format(parser.domain_name))
#         templatefile.write('grader_father_src_path = os.path.abspath(os.path.dirname(__file__)+os.path.sep+"..")\n')
#         templatefile.write('for line in open(\'./constrainsConfig/{0}_constrain.txt\',\'r\'): \n'.format(parser.domain_name)) 
#         #templatefile.write('for line in open(grader_father_src_path+"/constrainsConfig/%(domain_name)s_constrain.txt",\'r\'): \n')
#         templatefile.write('    exec(line)\n')

#         # ================ 
#         timeout_number = 1000
#         templatefile.write('@func_set_timeout({0})\n'.format(timeout_number)) # timeout_number =  1000 s 
#         templatefile.write('def myprove(f):\n')
#         templatefile.write('    s = Solver()\n')
#         templatefile.write('    s.add(Not(f))\n')
#         templatefile.write('    # print(s.sexpr())\n')
#         templatefile.write('    if s.check() == unsat:\n')
#         templatefile.write('        del s\n')
#         templatefile.write('        print(os.path.basename(__file__)[:-3]+" is proved.")\n')
#         templatefile.write('    else:\n')
#         templatefile.write('        print(os.path.basename(__file__)[:-3]+" failed to prove")\n')
#         templatefile.write('############################### start to prove! ####################################\n')
#         templatefile.write('hig = %(HIG_THEOREM)s\n')
#         templatefile.write('low = %(LOW_THEOREM)s\n')
#         templatefile.write('goal = And(\n')
#         templatefile.write('    Implies(\n')
#         templatefile.write('        And(constraint,simplify(low)),\n')
#         templatefile.write('        hig\n')
#         templatefile.write('    )\n')
#         templatefile.write(')\n')

#         templatefile.write('try:\n')
#         templatefile.write('    # print(simplify(goal))\n')
#         templatefile.write('    myprove(goal)\n')
#         templatefile.write('except func_timeout.exceptions.FunctionTimedOut:\n')
#         templatefile.write('    print(\'timeout and unknown,please open \\\'\'+os.path.basename(__file__)+\'\\\' and try.\')\n')

#         templatefile.close()
#         COMMAND_RUN = 'notepad {0}'.format(template_py_to_be_writed)


if __name__ == '__main__':
    pass


